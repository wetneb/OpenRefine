package org.openrefine.browsing.util;

import java.io.Serializable;
import java.util.Arrays;

import com.google.common.primitives.Longs;

/**
 * Stores statistics related to time values stored in a set of rows
 * (generated by an expression). The time values are represented as milliseconds
 * since Epoch, and stored individually in an array. This is different from the numeric
 * facet which does the binning on the fly, because the various possible scales for the 
 * timeline facet do not align (for instance, years are not integer multiples of days).
 * 
 * @author Antonin Delpeuch
 */
public class TimeRangeStatistics implements Serializable {

	private static final long serialVersionUID = -1671653217265336165L;
	
	// timeCount is an int because all the corresponding values are stored in an array anyway
	private final int    _timeCount;
    private final long   _nonTimeCount;
    private final long   _blankCount;
    private final long   _errorCount;
    private final long[] _timeValues;
    
	public TimeRangeStatistics(int timeCount, long nonTimeCount, long blankCount, long errorCount, long[] timeValues) {
		_timeCount = timeCount;
		_nonTimeCount = nonTimeCount;
		_blankCount = blankCount;
		_errorCount = errorCount;
		_timeValues = timeValues;
	}
	
	public int getTimeCount() {
		return _timeCount;
	}
	
	public long getNonTimeCount() {
		return _nonTimeCount;
	}

	public long getBlankCount() {
		return _blankCount;
	}
	
	public long getErrorCount() {
		return _errorCount;
	}
	
	/**
	 * The array of time values might be longer than the number
	 * of time values actually stored - see {@link getTimeCount()}
	 * to get the actual number of values stored.
	 */
	public long[] getRawTimeValues() {
		return _timeValues;
	}
	
	/**
	 * Actual array of time values stored by this object, without
	 * the blank padding space at the end.
	 */
	public long[] getTimeValues() {
		return Arrays.copyOfRange(_timeValues, 0, _timeCount);
	}
	
	/**
	 * Adds counts to the auxiliary fields.
	 * 
	 * @param nonTime
	 * @param blank
	 * @param error
	 * @return
	 */
	public TimeRangeStatistics addCounts(long nonTime, long blank, long error) {
		return new TimeRangeStatistics(_timeCount, _nonTimeCount + nonTime, _blankCount + blank, _errorCount + error, _timeValues);
	}
	
	/**
	 * Adds a valid time value represented as milliseconds since Epoch.
	 * 
	 * @param timeValue
	 * @return
	 */
	public TimeRangeStatistics addTime(long timeValue) {
		long[] newTimeValues = Longs.ensureCapacity(_timeValues, (int)(_timeCount + 1), Math.max(_timeValues.length - 1, 0));
		newTimeValues[_timeCount] = timeValue;
		return new TimeRangeStatistics(_timeCount + 1, _nonTimeCount, _blankCount, _errorCount, newTimeValues);
	}
	
	/**
	 * Sums the statistics with another one.
	 */
	public TimeRangeStatistics sum(TimeRangeStatistics other) {
		long[] newTimeValues = Longs.concat(getTimeValues(),
				other.getRawTimeValues());
		// leave the padding in the second array (it can be used again)
		
		return new TimeRangeStatistics(
				_timeCount + other.getTimeCount(),
				_nonTimeCount + other.getNonTimeCount(),
				_blankCount + other.getBlankCount(),
				_errorCount + other.getErrorCount(),
				newTimeValues);
	}
	
	@Override
	public boolean equals(Object other) {
		if (!(other instanceof TimeRangeStatistics)) {
			return false;
		}
		TimeRangeStatistics otherStats = (TimeRangeStatistics) other;
		return (_timeCount == otherStats.getTimeCount() &&
				_nonTimeCount == otherStats.getNonTimeCount() &&
				_blankCount == otherStats.getBlankCount() &&
				_errorCount == otherStats.getErrorCount() &&
				Arrays.equals(getTimeValues(), otherStats.getTimeValues()));
	}
	
	@Override
	public String toString() {
		return String.format("[TimelineStatistics time: %d, non-time: %d, blank: %d, error: %d, values: %s]",
				_timeCount, _nonTimeCount, _blankCount, _errorCount, Arrays.toString(getTimeValues()));
	}
	
	@Override
	public int hashCode() {
		return (int)(_timeCount + 5*_nonTimeCount + 13*_blankCount + 19*_errorCount);
	}
}
